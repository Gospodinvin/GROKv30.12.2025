diff --git a/features.py b/features.py
--- a/features.py
+++ b/features.py
@@ -1,11 +1,16 @@
 import numpy as np
 
 def build_features(candles, tf):
-    X=[]
-    scale = {"1":1.0,"2":1.2,"5":1.5,"10":2.0}[tf]
-    for i in range(1,len(candles)):
-        c=candles[i]
-        body=abs(c["close"]-c["open"])*scale
-        direction=np.sign(c["close"]-c["open"])
-        vol=(c["high"]-c["low"])*scale
-        X.append([body,direction,vol])
-    return np.array(X)
+    if len(candles) < 2:
+        return np.array([])  # Защита от слишком короткой истории
+
+    X = []
+    scale = {"1": 1.0, "2": 1.2, "5": 1.5, "10": 2.0}.get(tf, 1.0)
+    
+    for i in range(1, len(candles)):
+        c = candles[i]
+        body = abs(c["close"] - c["open"]) * scale
+        direction = np.sign(c["close"] - c["open"])
+        vol = (c["high"] - c["low"]) * scale
+        X.append([body, direction, vol])
+    
+    return np.array(X) if X else np.array([])
diff --git a/indicators.py b/indicators.py
--- a/indicators.py
+++ b/indicators.py
@@ -1,5 +1,7 @@
 import numpy as np
 
+# ... (старые функции остаются без изменений)
+
 def compute_rsi(closes, period=14):
     deltas = np.diff(closes)
     gain = np.where(deltas > 0, deltas, 0)
@@ -47,3 +49,38 @@ def scalping_strategy(indicators, patterns, regime):
         adj *= 1.2
 
     return np.clip(adj, -0.3, 0.3)
+
+# Новые индикаторы
+def compute_stochastic(closes, highs, lows, period=14):
+    if len(closes) < period:
+        return 50.0
+    low_min = np.min(lows[-period:])
+    high_max = np.max(highs[-period:])
+    current_close = closes[-1]
+    if high_max == low_min:
+        return 50.0
+    return 100 * (current_close - low_min) / (high_max - low_min)
+
+def compute_adx_strength(highs, lows, closes, period=14):
+    """Упрощённая оценка силы тренда (не полный ADX, но достаточно для фильтра)"""
+    if len(highs) < period + 1:
+        return 20.0
+    
+    tr = np.maximum(
+        highs[1:] - lows[1:],
+        np.maximum(abs(highs[1:] - closes[:-1]), abs(lows[1:] - closes[:-1]))
+    )
+    atr = np.mean(tr[-period:])
+    
+    up_move = highs[1:] - highs[:-1]
+    down_move = lows[:-1] - lows[1:]
+    
+    plus_dm = np.where((up_move > down_move) & (up_move > 0), up_move, 0)
+    minus_dm = np.where((down_move > up_move) & (down_move > 0), down_move, 0)
+    
+    plus_di = 100 * np.mean(plus_dm[-period:]) / (atr + 1e-9)
+    minus_di = 100 * np.mean(minus_dm[-period:]) / (atr + 1e-9)
+    
+    dx = abs(plus_di - minus_di) / (plus_di + minus_di + 1e-9) * 100
+    return dx  # >25 — сильный тренд
diff --git a/model.py b/model.py
--- a/model.py
+++ b/model.py
@@ -1,14 +1,33 @@
-# model.py  (переименовал класс для ясности)
 import numpy as np
+from sklearn.ensemble import RandomForestClassifier
 
-class CandleModel:
-    """
-    Лёгкая ML-модель без переобучения
-    """
-    def predict_proba(self, X):
-        if X.shape[0] == 0:
-            return np.array([[0.5, 0.5]])
-        momentum = X[:, 0]          # body size (scaled)
-        volatility = X[:, 2]        # range (high-low scaled)
-
-        prob_up = 0.5 + 0.4 * momentum - 0.3 * volatility
-        prob_up = np.clip(prob_up, 0.05, 0.95)
-
-        return np.vstack([1 - prob_up, prob_up]).T
+class CandleModel:
+    """
+    Улучшенная модель на RandomForest.
+    По умолчанию использует простую эвристику, но можно обучить на данных.
+    """
+    def __init__(self):
+        # Простая эвристика как fallback
+        self.fallback = True
+        self.model = None
+
+    def fit(self, X, y):
+        """Обучить модель на исторических данных"""
+        if len(X) < 10:
+            return
+        self.model = RandomForestClassifier(n_estimators=200, max_depth=6, random_state=42)
+        self.model.fit(X, y)
+        self.fallback = False
+
+    def predict_proba(self, X):
+        if X.shape[0] == 0:
+            return np.array([[0.5, 0.5]])
+        
+        if not self.fallback and self.model is not None:
+            return self.model.predict_proba(X)
+        
+        # Fallback эвристика (старая логика)
+        momentum = X[:, 0]
+        volatility = X[:, 2]
+        prob_up = 0.5 + 0.4 * momentum - 0.25 * volatility
+        prob_up = np.clip(prob_up, 0.05, 0.95)
+        return np.vstack([1 - prob_up, prob_up]).T
diff --git a/model_registry.py b/model_registry.py
--- a/model_registry.py
+++ b/model_registry.py
@@ -1,9 +1,9 @@
 from model import CandleModel
 
 MODELS = {
-    "1": CandleModel(),
-    "2": CandleModel(),
-    "5": CandleModel(),
-    "10": CandleModel(),
+    "1": CandleModel(),   # Можно позже обучить: MODELS["1"].fit(X_train, y_train)
+    "2": CandleModel(),
+    "5": CandleModel(),
+    "10": CandleModel(),
 }
 
 def get_model(tf: str):
diff --git a/patterns.py b/patterns.py
--- a/patterns.py
+++ b/patterns.py
@@ -66,6 +66,8 @@ def detect_patterns(candles):
     patterns = list(set(patterns))
     return patterns, min(score, 1.0)
 
+    # Улучшение: усиление паттернов в соответствии с трендом
+    trend_prob = trend_signal(candles)  # из trend.py
+    if trend_prob > 0.65 and any("bull" in p.lower() or "hammer" in p.lower() or "morning" in p.lower() for p in patterns):
+        score = min(score * 1.3, 1.0)
+    elif trend_prob < 0.35 and any("bear" in p.lower() or "shooting" in p.lower() or "evening" in p.lower() for p in patterns):
+        score = min(score * 1.3, 1.0)
+
+    return patterns, min(score, 1.0)
diff --git a/predictor.py b/predictor.py
--- a/predictor.py
+++ b/predictor.py
@@ -88,11 +88,34 @@ async def analyze(image_bytes=None, tf=None, symbol=None):
         "closes": closes
     }
 
-    features = build_features(candles, tf) or np.array([[0.1, 0, 0.1]])
-    X = features[-1].reshape(1, -1)
-    ml_prob = get_model(tf).predict_proba(X)[0][1]
+    # Исправленная и защищённая обработка фич
+    features = build_features(candles, tf)
+    if features is None or features.size == 0 or len(features) == 0:
+        features = np.array([[0.1, 0.0, 0.1]])  # нейтральная свеча
+
+    X = features[-1].reshape(1, -1)
+    ml_prob = get_model(tf).predict_proba(X)[0][1]
 
     patterns, pattern_score = detect_patterns(candles)
+
+    # Дополнительные индикаторы
+    highs = np.array([c["high"] for c in candles])
+    lows = np.array([c["low"] for c in candles])
+    stoch = compute_stochastic(closes, highs, lows)
+    adx = compute_adx_strength(highs, lows, closes)
+
+    indicators.update({
+        "stoch": round(stoch, 1),
+        "adx": round(adx, 1)
+    })
+
+    # Улучшение scalping_strategy
+    scalp_adj = scalping_strategy(indicators, patterns, regime)
+    if stoch < 20 and adx > 25:
+        scalp_adj += 0.12
+    if stoch > 80 and adx > 25:
+        scalp_adj -= 0.12
+
     trend_prob = trend_signal(candles)
     regime = market_regime(candles)
 
-    scalp_adj = scalping_strategy(indicators, patterns, regime)
     pattern_score = np.clip(pattern_score + scalp_adj, 0.0, 1.0)
 
     grok_prob = await call_grok(candles, patterns, regime, tf, symbol, indicators)
@@ -128,6 +151,17 @@ async def call_grok(candles, patterns, regime, tf, symbol, indicators):
         return 0.5
+    
+    # Улучшенный few-shot промпт
+    prompt = f"""Ты — профессиональный скальпер на Forex и крипте.
+
+Примеры:
+1. RSI=27, Stoch=18, паттерн=Hammer, тренд вверх → вероятность роста 0.78
+2. RSI=73, Stoch=85, паттерн=Shooting Star, тренд вниз → вероятность роста 0.25
+3. Doji в боковике, RSI=48 → вероятность роста 0.50
+
+Теперь анализируй:
+{symbol} {tf}мин | Режим: {regime}
+Паттерны: {", ".join(patterns) or "нет"}
+RSI: {indicators['rsi']:.1f} | Stoch: {indicators.get('stoch',50):.1f} | ADX: {indicators.get('adx',20):.1f}
+MACD: {indicators['macd']:.5f} | Bollinger: {indicators['bb']}
+
+Вероятность роста цены на 2–3 свечи вперёд? Ответь ТОЛЬКО числом от 0.00 до 1.00"""
 
     try:
         async with httpx.AsyncClient(timeout=15.0) as client:
